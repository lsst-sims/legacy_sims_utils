from __future__ import with_statement
import numpy as np
import os
import palpy as pal
import warnings
import unittest
import lsst.utils.tests as utilsTests
from lsst.utils import getPackageDir
import lsst.sims.utils as utils


class TimeTest(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        """
        Create list of control TAI and UTC values.

        UTC values are generated by entering calendar dates into the USNO
        JD calculator at

        http://aa.usno.navy.mil/data/docs/JulianDate.php

        TAI values are found from this table listing the relationship between
        TAI and UTC as a function of epoch

        https://hpiers.obspm.fr/eop-pc/earthor/utc/TAI-UTC_tab.html
        """

        jd_to_mjd = 2400000.5
        sec_to_day = 1.0/86400.0

        cls.utc_control = []
        cls.tai_control = []
        cls.year = []

        # all UTC values calculated at midnight UT
        # June 10, 1961
        mjd = 2437460.5 - jd_to_mjd
        dt = 1.4228180 + (mjd-37300.0)*0.001296
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1961)

        # June 10, 1962
        mjd = 2437825.5 - jd_to_mjd
        dt = 1.8458580 + (mjd-37665.0)*0.0011232
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1962)

        # June 10, 1963
        mjd = 2438190.5 - jd_to_mjd
        dt = 1.8458580 + (mjd - 37665.0) * 0.0011232
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1963)

        # June 10, 1964
        mjd = 2438556.5 - jd_to_mjd
        dt = 3.3401300 + (mjd - 38761.0)*0.001296
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1964)

        # June 10, 1965
        mjd = 2438921.5 - jd_to_mjd
        dt = 3.6401300 + (mjd-38761.0)*0.001296
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1965)

        # June 10, 1974
        mjd = 2442208.5 - jd_to_mjd
        dt = 13.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1974)

        # June 10, 1984
        mjd = 2445861.5 - jd_to_mjd
        dt = 22.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1984)

        # June 10, 1994
        mjd = 2449513.5 - jd_to_mjd
        dt = 28.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1994)

        # June 10, 1997
        mjd = 2450609.5 - jd_to_mjd
        dt = 30.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(1997)

        # June 10, 2003
        mjd = 2452800.5 - jd_to_mjd
        dt = 32.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(2003)

        # June 10, 2013
        mjd = 2456453.5 - jd_to_mjd
        dt = 35.0
        cls.utc_control.append(mjd)
        cls.tai_control.append(mjd + dt*sec_to_day)
        cls.year.append(2013)


    def test_tai_from_utc(self):
        """
        Test our transformation from UTC to TAI.
        """
        for utc, tai, year in \
            zip(self.utc_control, self.tai_control, self.year):

            tai_test = utils.taiFromUtc(utc)
            msg = "year: %s... %.12f != %.12f" % (year, tai, tai_test)
            self.assertAlmostEqual(tai_test, tai, 12, msg=msg)


    def test_tai_from_uts_from_pal(self):
        """
        Verify the UTC-to-TAI transformation against
        the same calculation done using palpy's dat method
        """

        # MJDs where leap seconds were added
        utc_list = np.array([37300.0, 37512.0, 45516.0, 448804.0, 457204.0])
        tai_control = np.array([uu + pal.dat(uu)/86400.0 for uu in utc_list])
        tai_test = np.array([utils.taiFromUtc(uu) for uu in utc_list])
        np.testing.assert_array_almost_equal(tai_control, tai_test, 15)

        np.random.seed(77)
        # random MJDs
        utc_list = np.random.random_sample(10)*(57204.0-37300.0) + 37300.0
        tai_control = np.array([uu + pal.dat(uu)/86400.0 for uu in utc_list])
        tai_test = np.array([utils.taiFromUtc(uu) for uu in utc_list])
        np.testing.assert_array_almost_equal(tai_control, tai_test, 15)

        # test times from before the first leap second
        utc_list = np.random.random_sample(10)*(57204.0-37300.0) + 100.0
        tai_control = np.array([uu + pal.dat(uu)/86400.0 for uu in utc_list])
        tai_test = np.array([utils.taiFromUtc(uu) for uu in utc_list])
        np.testing.assert_array_almost_equal(tai_control, tai_test, 15)

        # test times from after the last leap second
        utc_list = np.random.random_sample(10)*(57204.0-37300.0) + 57204.0
        tai_control = np.array([uu + pal.dat(uu)/86400.0 for uu in utc_list])
        tai_test = np.array([utils.taiFromUtc(uu) for uu in utc_list])
        np.testing.assert_array_almost_equal(tai_control, tai_test, 15)



    def test_utc_from_tai(self):
        """
        Test our transformation from TAI to UTC
        """
        for utc, tai, year in \
            zip(self.utc_control, self.tai_control, self.year):

            utc_test = utils.utcFromTai(tai)
            msg = "year: %s... %.12f != %.12f" % (year, utc, utc_test)
            self.assertAlmostEqual(utc_test, utc, 23, msg=msg)


    def test_roundtrip_boundary_values(self):
        """
        Test the round trip from UTC to TAI and back on values where
        leap seconds are added

        Data taken from

        https://hpiers.obspm.fr/eop-pc/earthor/utc/TAI-UTC_tab.html

        and

        http://aa.usno.navy.mil/data/docs/JulianDate.php
        """

        jd_to_mjd = 2400000.5
        boundary_values = []
        boundary_values.append(2439004.5 - jd_to_mjd) # September 1, 1965
        boundary_values.append(2443144.5 - jd_to_mjd) # January 1, 1977
        boundary_values.append(2450083.5 - jd_to_mjd) # January 1, 1996
        boundary_values.append(2439126.5 - jd_to_mjd) # January 1, 1966
        boundary_values.append(2456109.5 - jd_to_mjd) # July 1, 2012

        for bv in boundary_values:
            for utc in np.arange(bv-1.0e-5, bv+1.0e-5, 1.0e-6):
                tai = utils.taiFromUtc(utc)
                utc_test = utils.utcFromTai(tai)
                self.assertAlmostEqual(utc_test, utc, 15)


    def test_roundtrip_extremities(self):
        """
        Test the round trip from UTC to TAI and back on values outside
        the bounds when the first and last leap seconds were added
        """

        for utc in (100.0, 2000.0, 60000.0, 70000.0):
            tai = utils.taiFromUtc(utc)
            utc_test = utils.utcFromTai(tai)
            self.assertAlmostEqual(utc_test, utc, 15)


    def test_ut1_from_utc(self):
        """
        Test our conversion from UT1 to UTC by just checking that the
        values from our lookup table are properly applied.
        """

        utc_control = [48622.0, 48638.0, 49528.0, 51638.0,
                       53933.0]

        dt_control = [-0.1253, -0.16114, -0.20968, 0.2732930,
                      0.184717]

        sec_to_day = 1.0/86400.0
        for utc, dt in zip(utc_control, dt_control):
            ut1 = utils.ut1FromUtc(utc)
            dd = (ut1-utc)/sec_to_day
            self.assertAlmostEqual(dd, dt, 6)
            # adding dt to the utc introduces some rounding error,
            # so we do not get back the full 7 decimal places
            # specified by the data


    def test_utc_from_ut1(self):
        """
        Test that utcFromUt1 really does invert ut1FromUtc
        """

        np.random.seed(45)

        utc_arr = 48622.0 + (57711.0-48622.0)*np.random.random_sample(1000)
        ut1_arr = np.array([utils.ut1FromUtc(utc) for utc in utc_arr])
        utc_test = np.array([utils.utcFromUt1(ut1) for ut1 in ut1_arr])
        np.testing.assert_array_almost_equal(utc_arr, utc_test, 15)


    def test_ut1_warnings(self):
        """
        Test that a warning is raised if you ask ut1FromUtc to calculate
        UT1 for a UTC value that is outside the span of our data.
        """

        with warnings.catch_warnings(record=True) as context:
            ut1 = utils.ut1FromUtc(48621.5)
        self.assertEqual(ut1, 48621.5)
        self.assertIn("We will return UT1-UTC = 0, for lack of a better idea",
                      str(context[-1].message))

        with warnings.catch_warnings(record=True) as context:
            ut1 = utils.ut1FromUtc(57711.5)
        self.assertEqual(ut1, 57711.5)
        self.assertIn("We will return UT1-UTC = 0, for lack of a better idea",
                      str(context[-1].message))


    def test_ut1_from_utc_leap_seconds(self):
        """
        Test ut1FromUtc and utcFromUt1 at and near points
        where discontinuous jumps in UT1-UTC occur in the data
        """
        data_dir = os.path.join(getPackageDir('sims_data'), 'lookUpTables')
        data_file = os.path.join(data_dir, 'dut1_table.txt')
        data = np.genfromtxt(data_file).transpose()
        utc_data = data[0]
        dut_data = data[1]
        leap_second_indices = np.where(np.diff(dut_data)>0.1)[0]
        for ix in leap_second_indices:
            utc = utc_data[ix]
            dut = dut_data[ix]
            ut1 = utils.ut1FromUtc(utc)
            self.assertAlmostEqual(ut1, utc+dut/86400.0, 15)
            utc_test = utils.utcFromUt1(ut1)
            self.assertAlmostEqual(utc_test, utc, 15)

            # consider values just to the left of the leap second
            utc = utc_data[ix+1]-1.0e-6
            slope = (dut_data[ix]-dut_data[ix-1])/(utc_data[ix]-utc_data[ix-1])
            dut = dut_data[ix] + slope*(utc-utc_data[ix])
            ut1 = utils.ut1FromUtc(utc)
            self.assertAlmostEqual(ut1, utc+dut/86400.0, 15)
            # make sure that ut1 is more like the values to the left of the leap second
            # than the values to the right
            self.assertGreater(np.abs(dut-dut_data[ix+1]), np.abs(dut-dut_data[ix-1]))
            utc_test = utils.utcFromUt1(ut1)
            self.assertAlmostEqual(utc_test, utc, 15)

            # consider values just to the right of the leap second
            utc = utc_data[ix+1]+1.0e-6
            slope = (dut_data[ix+1]-dut_data[ix+2])/(utc_data[ix+1]-utc_data[ix+2])
            dut = dut_data[ix+1] + slope*(utc-utc_data[ix+1])
            ut1 = utils.ut1FromUtc(utc)
            self.assertAlmostEqual(ut1, utc+dut/86400.0, 15)
            # make sure that ut1 is more like the values to the right of the leap second
            # than the values to the left
            self.assertGreater(np.abs(dut-dut_data[ix]), np.abs(dut-dut_data[ix+1]))
            utc_test = utils.utcFromUt1(ut1)
            self.assertAlmostEqual(utc_test, utc, 15)


    def test_dtt_from_utc(self):
        """
        Test our method to find TT-TAI in seconds
        """

        precision = 11 # expect 0.1 nanonsecond precision

        self.assertAlmostEqual(utils.dttFromUtc(42588.0), 32.1840, precision)

        self.assertAlmostEqual(utils.dttFromUtc(57020.0), 32.1840276970, precision)

        self.assertAlmostEqual(utils.dttFromUtc(43679.0), 32.1840054460, precision)

        self.assertAlmostEqual(utils.dttFromUtc(46459.0), 32.1840146120, precision)

        self.assertAlmostEqual(utils.dttFromUtc(52629.0), 32.1840262340, precision)

        self.assertAlmostEqual(utils.dttFromUtc(56829.0), 32.1840276936, precision)

        self.assertAlmostEqual(utils.dttFromUtc(56999.0), 32.1840276961, precision)


    def test_tt_from_tai(self):
        """
        Test our method to convert from TAI to TT (Terrestrial Time)
        """

        np.random.seed(99)
        tai_arr = np.random.random_sample(10)+43000.0

        for tai in tai_arr:
            self.assertAlmostEqual(utils.ttFromTai(tai), tai+0.00037250, 8)


    def test_tdb_from_tt(self):
        """
        Test our method to convert from Terrestrial Time (TT) to Barycentric Dynamical Time (TDB)
        """

        sec_to_day = 1.0/86400.0

        tt_control = [57388.645, 46132.112]
        jd_minus_control = [5844.15, -5412.39] # the rounding of the JD to two decimals
                                             # and subtracting of 2451545.0 was done by
                                             # hand, to check that tdbFromTt does it correctly

        for tt, jd in zip(tt_control, jd_minus_control):
            gg_deg = 357.53 + 0.9856003*jd
            gg_rad = np.radians(gg_deg)
            dt = 0.001658*np.sin(gg_rad) + 0.000014*np.sin(2.0*gg_rad)
            tdb = utils.tdbFromTt(tt)
            dt_test = (tdb-tt)/sec_to_day
            self.assertAlmostEqual(dt_test, dt, 6)


    def test_modified_julian_date_class(self):
        """
        Test the construction of ModifiedJulianDate
        """
        mjd1 = utils.ModifiedJulianDate(TAI=57388.0)
        mjd2 = utils.ModifiedJulianDate(UTC=mjd1.UTC)
        self.assertEqual(mjd1.TAI, mjd2.TAI)
        self.assertEqual(mjd1.UTC, mjd2.UTC)
        self.assertEqual(mjd1.TT, mjd2.TT)
        self.assertEqual(mjd1.TDB, mjd2.TDB)
        self.assertEqual(mjd1.dut, mjd2.dut)

        with self.assertRaises(RuntimeError) as context:
            mjd3 = utils.ModifiedJulianDate()
        self.assertEqual(context.exception.args[0],
                         "You must specify either TAI or UTC to "
                         "instantiate ModifiedJulianDate")


def suite():
    """Returns a suite containing all the test cases in this module."""
    utilsTests.init()
    suites = []
    suites += unittest.makeSuite(TimeTest)

    return unittest.TestSuite(suites)

def run(shouldExit=False):
    """Run the tests"""
    utilsTests.run(suite(), shouldExit)

if __name__ == "__main__":
    run(True)
